# Get Started {#_2_getStarted}

Here, we will go through some basic steps for users to build the placer and run a placement flow for a new design/device with a new placement configuration:
1. Build the Placer
2. Run An Example
3. Set the Placement Configuration in JSON file
4. Extract Design Information from Vivado
5. Extract Device Information from Vivado
6. (Optional) Load the Output Placement in Vivado
7. (Optional) Visualize the Placement Convergence Procedure
8. (Optional) Customize the Placement Flow

**1. Build the Placer**
First of all, users need to download the project and the command below will download it from GitHub:
```
git clone https://github.com/zslwyuan/AMF-Placer.git
```
We provide a script to build the placer and users can run the following command in the project root directory:

```bash
./build.sh
```

The built executable can be found in the directory "build".

**2. Run An Example**

Below is a command that users can try to run in the "build" directory. It will run the placement flow according to a given JSON configuration, where design/device/paramters are specified.

```bash
./AMFPlacer ../benchmarks/testConfig/OpenPiton.json
```

Users may find that AMFPlacer prints somethings in the terminal and if you are interested in the details of those information, you can find the concrete explanation [here](@ref _6_runtimeLog).

**3. Set the Placement Configuration in JSON file**

By checking the content of the JSON file in the command argument above, you may notice the major settings of our placer. 
Generally, we need to let the placer know where are the data of the design and devices, whether the placer should dump some log text/archieve files for further checking or evaluation, and some parameters related to the algorithms in the placer.

Below, we explain some of the settings. If users target at Xilinx VCU108, users may only need to change the parameters related to the design benchmark, which we mark with \[DESIGN\]. We also mark others parameters with \[DEVICE\], \[DEBUG\] and \[PLACER\]. Some optional parameters can be disable by commenting out by "//". Please be aware that no matter the value types are string or not, the value should be wrapper by " " as syntax requirement.
```cpp
{
    "vivado extracted design information file": "" ,// ==> the location of the design netlist zip file [DESIGN]
    "vivado extracted device information file" : "" ,// ==> the location of the device zip file [DEVICE]
    "special pin offset info file":"" ,// ==> the location of a information file indicating the offset of pins relative to the coordinate of the device site. (e.g. PCIE bank spans in a long range) [DEVICE]
    "cellType2fixedAmo file": "" ,//==> the location of a information file indicating the resource demand of each type of design standard cells [DEVICE]
    "cellType2sharedCellType file": "" ,// ==> the location of a information file indicating the resource demand of each type of design standard cells [DEVICE]
    "sharedCellType2BELtype file": "" ,// ==> the location of a information file indicating the DeviceSite/DeviceBEL demand of each type of design standard cells [DEVICE]
    "mergedSharedCellType2sharedCellType": "" ,// ==> the location of a information file indicating how some types of standard cells can be mapped different types of BEL slots in different types of DeviceSite [DEVICE]
    "unpredictable macro file": "" ,//==> the location of a information file indicating some macros which cannot be identified by AMF-Placer which we can detect in Vivado [DESIGN]
    "fixed units file": "" ,// ==> the location of a information file indicating some elements, locations of which are fixed on the device [DESIGN]
    "clock file": "" ,//==>  (Optional) the location of a information file indicating the clock driver pins in the design [DESIGN]
    "designCluster":  "" ,//==> (Optional) the location of a information file indicating some user-defined clusters for optimization [DESIGN]
    "Dump Cluster file": "" ,// ==> (Optional) the location where the information of clusters generated by initial partitioning should be dumped. [DEBUG]
    "Dump Cluster Simulated Annealig file": "", // ==> (Optional) the location where the trace of the SA procedure should be dumped. [DEBUG]
    // "DumpCLBLegalization" :"" ,// ==> (Optional) the location where the information of CLB legalization should be dumped. [DEBUG]
    // "SLICEL_LUT":  ==> (Optional) the location where the information of SLICEL_LUT density should be dumped. [DEBUG]
    // "DumpLUTFFCoordTrace":"" //  ==> (Optional) the location where the trace of LUT/FF coordinate change should be dumped. [DEBUG]
    // "DumpCARRYCoordTrace":"" ,// ==> (Optional) the location where the trace of CARRY coordinate change should be dumped. [DEBUG]
    // "Dump MacroDensity":"" ,// ==> (Optional) the location where the trace of macros coordinate change should be dumped. [DEBUG]
    // "Dump Cell Density":"" ,// ==> (Optional) the location where the trace of standard cells coordinate change should be dumped. [DEBUG]
    // "DumpLUTCoordTrace": "" ,//==> (Optional) the location where the trace of LUT coordinate change should be dumped. [DEBUG]
    // "DumpDSPCoordTrace":"" ,// ==> (Optional) the location where the trace of DSP coordinate change should be dumped. [DEBUG]
    // "DumpFFCoordTrace": "" ,// ==> (Optional) the location where the trace of FF coordinate change should be dumped. [DEBUG]
    // "DumpAllCoordTrace" : "" ,// ==> (Optional) the location where the trace of All elements' coordinate change should be dumped. [DEBUG]
    "GlobalPlacerPrintHPWL": "" ,// ==> (Optional) indicate whether print out the detailed changes of HPWL during global placement. [DEBUG]
    "DumpCLBPacking" : "" ,// ==> (Optional) indicate where to dump the information of CLB packing
    "DumpLUTFFPair": "" ,// ==> (Optional) indicate where to dump the information of LUT-FF pairing
    "DumpClockUtilization": "" ,// ==> (Optional) indicate whether print out the detailed changes of clock utilization [DEBUG]
    // "DumpMacroLegalization" : "" ,// ==> (Optional) indicate where print out macro legalization information [DEBUG]
    // "MacroLegalizationVerbose" : "" ,//==> (Optional:default "false") indicate whether print out DSP/BRAM macro legalization information during runtime [DEBUG]
    // "CLBLegalizationVerbose" :  "" ,//==> (Optional:default "false") indicate whether print out CLB legalization information during runtime [DEBUG]
    "Simulated Annealing restartNum":"", //  ==> a number indicate how many times the SA procedure should restart [PLACER]
    "Simulated Annealing IterNum": "" ,// ==> a number indicate the total iteration number the SA procedure should conduct [PLACER]
    // "RandomInitialPlacement" :"" //  ==> (Optional:default "false") indicate whether the initial placement is randomly generated [PLACER]
    "DrawNetAfterEachIteration":  "" ,//==> (Optional:default "false") indicate whether use OpenGL to draw the nets after each iteration of SA procedure [PLACER]
    "PseudoNetWeight": "" ,//==> indicate the initial pseudo net weight which controls the placer convergence speed. [PLACER]
    "GlobalPlacementIteration": "" ,//==> indicate the total number of the global placement iterations [PLACER]
    "clockRegionXNum":"" ,// ==> indicate how many clock region in a row on the device [DEVICE]
    "clockRegionYNum":  "" ,//==> indicate how many clock region in a column on the device [DEVICE]
    "clockRegionDSPNum": "" ,//==> indicate the threshold number of DSPs in a clock region during initial SA placement [PLACER]
    "clockRegionBRAMNum": "" ,//==> indicate the threshold number of BRAMs in a clock region during initial SA placement [PLACER]
    "jobs": "" ,// ==> indicate the parallelism of the placer [PLACER]
    "y2xRatio": "" ,// ==> indicate the weight of Y routing net compared to X routing net [PLACER]
    "ClusterPlacerVerbose": "" ,//==> (Optional:default "false") indicate whether the SA cluster placer print outs detailed information during runtime [DEBUG]
    "GlobalPlacerVerbose":  "" ,//==> (Optional:default "false") indicate whether the global placer print outs detailed information during runtime [DEBUG]
    "DirectMacroLegalize": "" ,//==> (Optional:default "false") indicate whether AMFPlacer use direct macro legalization instread of the progressive legalization (2-phase legalization)
    // "SpreaderSimpleExpland":  "" ,//==> (Optional:default "false") indicate whether the cell spreader finds the cell spreading window in a simple approach [PLACER]
    // "pseudoNetWeightConsiderNetNum" : "" ,// ==> (Optional:default "true") indicate whether the wirelength optimizer considers the interconnection density for psuedo net weight [PLACER]
    // "disableSpreadingConvergeRatio" :"" ,// ==> (Optional:default "false") indicate whether the cell spreader utilizes forget-rate-based cell spreading location update [PLACER]
    "drawClusters": "" ,//==> (Optional:default "false") indicate whether the SA placer draws the cluster placement with OpenGL [DEBUG]
    "MKL": "" ,//==> (Optional:default "false") indicate whether wirelength optimizer is based on MKL library when using OSQP placer, which can set constraints for the quadratic model [PLACER]
    "dumpDirectory": "" ,//==> indicate where the "DUMP" files should be located. [PLACER]
    //"useUnconstrainedCG" : "" ,// ==>(Optional:default "true") indicate whether wirelength optimizer uses Eigen3, which cannot set constraints, to solve the quadratic problem. If false, OSQP solver which can set constraints for the quadratic model, will be involved to replace Eigen3. [PLACER]
}
```


**4. Extract Design Information from Vivado**
Users can go through the following steps to extract the information of specific designs. Please note that we have provide a set of benchmarks for VCU108 which can be found in "benchmarks/VCU108/design". Please note that for a design, you can go through this extraction flow just ONE TIME. You DON'T need to do this every time your run AMFPlacer.

* a. Please ensure that your design has sucessfully gone through the general Vivado flow to "Generate Bistream". In this way, Vivado will check your design to avoid some bugs in  frond-end design stages, and meanwhile we can extrat information of your design, even part of which are some of them are blackbox IPs in Vivado, from the "Implemented Design" which has gone through the placement and routing of Vivado.
* b. Open the Tcl script "benchmarks/vivadoScripts/extractDesignInfo.tcl" in the project directory where you can find the below content at the beginning and modify them according to the comments suggesting.
```tcl
# replace this with the name for your benchmark
set benchmarkName "OpenPiton" 
# replace this path with your one to specify where to store the files of extracted data
set targetFolderPath "/home/tingyuan/tmpFiles/" 
```
* c. Open your design in Vivado and "Open Implemented Design" and execut the command below in the Tcl console of Vivado. It might take tens of minutes or ~1hour to finish the extraction due to the slow Tcl execution related to strings and IOs in Vivado.
```tcl
# replace XXXXX to indicate where your AMFPlacer is located.
source XXXXX/AMF-Placer/benchmarks/vivadoScripts/extractDesignInfo.tcl
```
* d. Finally, you should be able to find the extracted files in target folder path set by you. Below is an example showing the generated files for OpenPiton:

<center>
<img src="designFiles.png" align="center"  alt="Design Files" title="Design Files" width="300" /> 
</center>

**5. Extract Device Information from Vivado**
Users can go through the following steps to extract the information of specific device in Vivado. Please note that we have provided device information for VCU108 which can be found in "benchmarks/VCU108/device". Please note that for a device, you can go through this extraction flow just ONE TIME. You DON'T need to do this every time your run AMFPlacer.

* a. Please ensure that your Vivado has the license for the specific device, so you can open the Device window by clicking on the top bar "Window->Device"

* b. Open the Tcl script "benchmarks/vivadoScripts/extractDeviceInfo.tcl" in the project directory where you can find the below content at the beginning and modify them according to the comments suggesting.
```tcl
# replace this with the name for your device
set deviceName "VCU108" 
# replace this path with your one to specify where to store the files of extracted data
set targetFolderPath "/home/tingyuan/tmpFiles/" 
```
* c. Open your design of your target device or just create empty project of the target device. Open the Device window by clicking on the top bar "Window->Device" and execut the command below in the Tcl console of Vivado. It might take tens of minutes or 6 hours to finish the extraction due to the slow Tcl execution (get_site_pins is SOOOO slow...) related to strings and IOs in Vivado. (You can run the script at night and go to bed ealier..)
```tcl
# replace XXXXX to indicate where your AMFPlacer is located.
source XXXXX/AMF-Placer/benchmarks/vivadoScripts/extractDeviceInfo.tcl
```
* d. Finally, you should be able to find the extracted files in target folder path set by you. Below is an example showing the generated files for VCU108:

<center>
<img src="deviceFiles.png" align="center" alt="Device Files" title="Device Files" width="300"  /> 
</center>

Please note that since the exact location of the extracted site/BEL/pins are not provided, the Tcl script uses a Python script to map the sites/BEL/pin to specifc location based on their names and hierarchy. If users change their target devices from VCU108 or Xilinx Ultrascale Series products, they might need to change the Python script to adapt to some other FPGA architectures.

**6. Load the Output Placement in Vivado**
After the placemnt completes, a Tcl file will be generated in the directory specified by "dumpDirectory" in the JSON configuration file. Currently, the mentioned Tcl file is named "DumpCLBPacking-first-0.tcl" since it is dumped by the ParallelCLBPacker.

You can go through the following steps to load the AMFPlacer result into Vivado Implementation.

* a. Please ensure that your Vivado has the license for the specific device, so you can open the Device window by clicking on the top bar "Window->Device"
* b. Open your design in Vivado and click on "Open Implemented Design" in the flow navigator and execut the command below in the Tcl console of Vivado.

```tcl
# replace XXXXX with the path specified by the "dumpDirectory" you specified in the configuration files.
source XXXXX/DumpCLBPacking-first-0.tcl
```
* c. Then you can wait until the placement and routing finish. The Tcl script will clear the Vivado placement result and packing information, which might take ~10 minutes for medium-size designs (50% resource). Then it will place the cells according to the AMFPlacer result, which might take ~20 minutes for medium-size designs (50% resource). Finally, it will call Vivado Placer to verify AMFPlacer's placement, handle a small number (tens) of Xilinx primitive cells (e.g., the clock buffer placement) and do routing. 

Below is a screenshot when the AMFPlacer's placement is loading on Vivado. The orange blocks means the cells are placed are set fixed on the device.

<center>
<img src="loadPlacement.png" align="center" alt="AMFPlacer's placement is loading on Vivado" title="AMFPlacer's placement is loading on Vivado" width="400" /> 
</center>

For users' testing and exploration, we provide the Vivado projects of the benchmarks with post-implementation designs on Google Drive (size of each >100MB): [OpenPiton](https://drive.google.com/file/d/1b0sWwoWq6XyiqWWxUxLlI9rAszVmR5WI/view?usp=sharing), [MiniMap2](https://drive.google.com/file/d/1Dp1nL9KYuBgBjU2-1eL3IzYpl4OFD7As/view?usp=sharing), and uploading...

Users can directly open the .xpr file with Vivado. There might be some warnings because your Vivado version is not matched with the IP cores in the design or some IP core instances cannot be found in your system. Please ignore them and do not update the ip core or re-synthesis because these operations will change the netlist. 


<center>
<img src="errors.png" align="center" alt="openImpled errors" title="openImpled errors" width="300" /> 
</center>


Users can directly "Open Implemented Design" and source the tcl file generated by AMF-Placer.


<center>
<img src="openImpl.png" align="center" alt="openImpled Design" title="openImpled Design" width="200" /> 
</center>

This placement loading flow might be a bit tricky since we are trying to be compatible with Vivado. Theoratically, since we utilize "catch" in the Tcl script to handle the errors, the flow should not be stopped by those minor exceptions and we have tested this flow with Vivado 2019-2021. If you encounter unexpected problems, please feel free to let us know in [GitHub Issue](https://github.com/zslwyuan/AMF-Placer/issues).

There might be some known problems when you are trying to load the generated placement into Vivado. Please [Existing Problems When Exporting To Vivado](@ref _7_portabilityToVivadoProblem) for reasons and solutions.

**7. Visualize the Placement Convergence Procedure**

If users set the "DumpAllCoordTrace" parameter in the JSON configuration file, a series of "DumpAllCoordTrace-XXX.gz" files which record the location of the design elements will be dumped to the specified directory. Each dumped archive file is for a lower-bound placement iteration or a upper-bound placement iteration in the global placement procedure.

For evaluation and debugging, we provide Python script ("benchmarks/analysisScripts/paintPlacement.py") for users to visualize the placement trace with OpenGL. Please ensure that you have install OpenGL libs, if not you can install them by:

```
pip install PyOpenGL PyOpenGL_accelerate
```

Users can visualize the trace files by the following command:

```
usage example:
python paintPlacement.py -d xxxx/minimap2_allCellPinNet.zip -t xxxxx/dumpData_minimap_GENE -o xxxx/dumpData_minimap_GENE
```

1. -d indicate the design information archive, e.g.   benchmarks/VCU108/design/minimap2/minimap2_allCellPinNet.zip
2. -t indicate the path where the placement trace archives are dumped. (the trace files are required to be named as DumpAllCoordTrace-xxx.gz currently)
3. -o indicate the path where you want to store the output images (png) generated according to the trace files

Below is a screenshot showing the archive files and the generated images. With this images, you can easily generate a video of the convergence procedure with ffmpeg related commands/tools.

<center>
<img src="visProc.png" align="center" alt="Visualized Example" title="Visualized Example" width="500" /> 
</center>